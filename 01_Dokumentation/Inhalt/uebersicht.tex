\chapter{Systemübersicht}

Für ein minimalistisches Betriebssystem werden einige Grundbausteine
benötigt. Zunächst muss die Hardware bzw. der Chip initialisiert
werden, indem verschiedene Zeitquellen, Timer und die globale
Interruptverwaltung konfiguriert werden. \todo{verweis} Bevor
das eigentliche Betriebssystem gestartet werden kann, müssen zudem
diverse Strukturen für die Tasks aufgestellt werden, sodass diese
unabhängig voneinander lauffähig sind. \todo{verweis}
Zum Starten des Systems wird mittels eines modifizierten Aufrufs
der Dispatcher erstmalig durchlaufen und die erste Task zum Ausführen
vorbereitet. Dabei wird auch der Scheduler aufgerufen, der, abhängig vom
ausgewählten Algorithmus, die nächste Task bestimmt.\todo{verweis}

Die soeben genannten Module würden für ein multitasking-fähiges
Betriebssystem bereits ausreichen. Jedoch wäre sein Funktionsumfang
sehr beschränkt. Bislang besteht noch keine Möglichkeit einer sicheren
Interaktion zwischen zwei oder mehreren Tasks. Hierfür werden 
z.B. kritische Bereiche oder Signale benötigt, welche das Modul
Synchronisation bereitstellt. Die Anwendung von Wartezeiten innerhalb
Tasks setzt eine Systemzeit vorraus. Das Modul Zeiten \todo{verweis} verwendet hierfür Trigger der Hardware.
Eine große Erleichterung im Entwicklungsprozess (und auch 
im späteren Anwendungsfall) ist
die Verwendung von Collections, welche Datenpakete hantierbar 
macht. Gleichzeitig verbessert sich die Lesbarkeit des
Programmcodes.

\section{Hardware}
Als Zielplattform wurde die weit verbreitete AVR-Serie von Atmel
verwendet. Jedoch wurde während der Umsetzung darauf geachtet, 
dass bei einem Plattformwechsel möglichst wenig Code angepasst
werden muss. Als Entwicklungstool wurde der AVR-Simulator verwendet,
welcher innherhalb des AVR-Studios von Atmel bereitgestellt wird.
Als Zielbaustein wurde der \mbox{ATxmega128A1} gewählt.

Die minimale Vorraussetzung an die Hardware ist ein Timer
und ein Interruptsystem.
Die Periode des Timers muss bekannt oder definierbar sein.
Sind (wie im Fall vom \mbox{ATxmega128A1}) weitere Timer
verfügbar, können diese vom Entwickler frei verwendet werden, 
unter der Bedingung, dass der Systemtimer nicht beeinflusst 
wird.

\subsection{Zeitquellen}
Zuallererst wird der interne Oszillator auf eine Systemfrequenz von $f_{S} = 32 \text{MHz}$ konfiguriert. Dadurch können durch
nachgeschaltete Teiler diverse Frequenzen an weiterer
Peripherie erzeugt werden \todo{verweis}.

\subsection{Dispatcher Timer}
Damit nach Ablauf der Zeitscheibe einer Task der Dispatcher 
aufgerufen wird, muss ein Dispatcher Timer initialisiert werden.
Dieser löst, unabhängig vom Ausführungszustand\todo{verweis}
\footnote{Es sei denn, die Task befindet sich in einem kritischen 
(Interrupt gesperrten) Abschnitt} der aktuellen Task, einen 
Interrupt aus, in dessen Service Routine der Dispatcher aufgerufen
wird. Außerdem dient der Timer zur Berechnung der aktuellen
Systemzeit.

\begin{lstlisting}[language=C, label=lst:DispatcherTimer, caption=Initialisierung Dispatcher Timer]
void initDispatcherTimer(){
	TCF0.CTRLB = TC_WGMODE_NORMAL_gc;
	TCF0.PER = 0x7D00;
	TCF0.INTCTRLA = TC_OVFINTLVL_HI_gc;
}
\end{lstlisting}

In dieser Konfiguration zählt der Timer aufwärts bis zum Wert der
Periode (\texttt{TCF0.PER}) und wird auf 0 zurückgesetzt. 
Gleichzeitig löst er beim Zurücksetzen einen Überlauf-Interrupt aus.

Wird als Zeitquelle die Systemfrequenz $f_{S}$ ohne Vorteiler
gewählt, so ergibt sich folgendes Intervall:
\begin{equation}
\begin{split}
t_{per} = \frac{7\text{D}00_{16}}{32\text{MHz}} = 1\text{ms}
 \end{split}
 \label{eq:intervall}
\end{equation}

In der Annahme, dass keine kritische Abschnitte verwendet werden
wird somit in Abständen von $t_{per}$ ein Kontextwechsel herbeigeführt. Sollten kritische Abschnitte Anwendung finden liegt
es am Entwickler, diese möglichst kurz zu halten. Solange sie
deutlich unter $t_{per}$ liegen gibt es keine Probleme. Bedenklich 
wird es, wenn die Ausführung des kritischen Bereichs länger als 
$t_{per}$ dauert,
da hierbei ein oder im schlimmsten Fall gleich mehrere 
Interruptsignale verloren gehen und dadurch u.a. die Systemzeit
nicht mehr präzise ist.

\subsection{Interrupts}
Auch die Konfiguration des Interruptsystems ist nicht besonders
aufwändig. Auf dem \mbox{ATxmega128A1} muss jediglich das
dem Dispatcher Timer entsprechende Interuptlevel scharf gestellt
und das globale Interruptenable gesetzt werden.

Da die Funktionen zum Löschen oder Setzen des Interrupts auch
mit dem Betreten oder Verlassen eines kritischen Abschnitts
gleichzusetzen sind, werden sie plattformunabhängig exportiert.
Wichtig hierbei ist nur, dass die Funktionen inline aufgerufen
werden, sodass im Anwendungsfall der Stack nicht manipuliert wird.
Dies wird beim AVR-Compiler durch das Attribut 
\texttt{always\_inline} verwirklicht.
\begin{lstlisting}[language=C, label=lst:interruptDisEnable, caption=Export der Interruptfunktionen]
static void __attribute__((always_inline)) enableInterrupts(){
	sei();
}

static void __attribute__((always_inline)) disableInterrupts(){
	cli();
}
\end{lstlisting}

\section{Strukturen}
In einem multitaskingfähigen Betriebssystem müssen neben dem
Stack für jede Task auch ein sogenannter Task-Controll-Block
(TCB) initialisiert werden. Dieser enthält Informationen
über den aktuellen Zustand, die Priorität\todo{verweis scheduler},
den Stack-/pointer und Zeitangaben \todo{verweis schlafen}.

\subsection{Task-Control-Block}
Als mögliche Zustände einer Task wurden wie üblich 
\texttt{READY}, \texttt{RUNNING}, \texttt{WAITING} und 
\texttt{KILLED} definiert. Bei der Priorität bedeutet
eine kleinere Zahl einen höheren Vorrang (mit 0 als
höchsten Wert).
\begin{lstlisting}[language=C, label=lst:TCB, caption=Task-Control-Block]
typedef volatile struct strucTCB{
	volatile uint8_t prio;
	volatile uint8_t id;
	volatile uint8_t* stackPointer;
	volatile uint8_t* stackBeginn;
	volatile uint16_t stackSize;
	volatile uint32_t waitUntil;
	volatile uint8_t tmpPrio;
	volatile taskstate state;
}taskControlBlock;
\end{lstlisting}

\subsection{Stack und Stackpointer}
Zur Initialisierung eines TCB's gehört auch der eigentliche
Stack sowie dessen Zeiger. Daher muss vor dem Start des
Betriebsystems auch der Speicherbereich des Stacks reserviert
und vorbereitet werden.

Zur Vorbereitung eines Stacks wird an seiner ersten und letzten 
Speicherstelle eine Magicnumber\footnote{z.B. AA$_{16} = 
10101010_{2}$} eingefügt. Mit dieser
soll erkannt werden, ob es zu einem Stacküberlauf gekommen ist.
\todo{verweis dispatcher} Zudem wird an die vorletzte Stelle
die Rücksprungadresse des Programmcodes kopiert, welcher in der
jeweiligen Task ausgeführt werden soll. Der Task-Stackpointer
wird daraufhin auf die Adresse x stellen überhalb der letzten
Adresse gesetzt. Das x entspricht hierbei der Anzahl der
CPU-Register.\todo{verweis dispatcher}

Zum Starten des Systems wird bei der Starttask der Stackpointer
nochmals verändert: Um gleich zur Rücksprungadresse bzw. 
Startadresse des Task-Programmcodes zu gelangen, wird der
Stackpointer direkt überhalb dieser Adresse gesetzt und
mittels \texttt{RET}-Befehl zu selbiger gesprungen.
\todo{naming beer??}
\begin{lstlisting}[language=C, label=lst:systemstart, caption=Systemstart]
void beerOS_start(taskControlBlock* firstTask, void (*scheduler_init)(void)){
	currentTask = firstTask;
	scheduler_init();
	time_init();
	firstTask->state = RUNNING;
	mainSP = SP;
	//set stack pointer of starting task next to taskaddress
	SP = firstTask->stackBeginn+firstTask->stackSize-progcntOffset;
	//start task
	asm volatile ("ret");
}
\end{lstlisting}

\section{Dispatcher}
Im Betrieb soll es für jede Tasks so aussehen, als wäre sie die
einzige im System. D.h. wird eine Task unterbrochen,
müssen nicht nur alle Register und der CPU-Zustand gesichert,
sondern auch der Stackpointer gespeichert und umgesetz
werden. 


\section{Scheduler}

\section{Synchronisation}

\section{Zeiten}

\section{Collections}

\section{Exceptions}